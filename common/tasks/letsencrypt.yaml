---
# file: roles/osctl/tasks/letsencrypt.yaml
#
# Note: Set the variable "letsencrypt_test: true" to use the letsencrypt test
# server. This variable is referenced by the handler "run get_letsencrypt_cert".

# Note: This file used to handle backing up letsencrypt
# certificates to a tar.gz in /etc/letsencrypt
# and restoring from this backup if it is present
# through usr_local_sbin_get_letsencrypt_cert.j2
# This is no longer done. A new method for handling  
# backups is yet to be decided


# these facts are for the letsencrypt backup routine
# - set_fact:
#     homedir: "{{ lookup('ansible.builtin.env', 'HOME') }}"
#   when:
#     ansible_version.major >= 3

# - set_fact:
#     homedir: "{{ lookup('env','HOME') }}"
#   when:
#     ansible_version.major < 3

# - name: set_fact letsencrypt_archive if undefined
#   set_fact:
#     letsencrypt_archive: "{{ homedir }}/archive/letsencrypt"
#   when:
#     letsencrypt_archive is undefined

- name: set_fact letsencrypt_test
  set_fact:
    letsencrypt_test: false
  when:
    letsencrypt_test is undefined

- name: get initial python3 status
  stat:
    path: /usr/bin/python3
  register: initial_python3_status

- name: stat letsencrypt opt dir
  stat:
    path: /opt/letsencrypt
  register: initial_optdir_status

# new certbot installation method, no need for this flag 
# - name: stat certbot dir
#   stat:
#     path: /opt/letsencrypt/bin/certbot
#   register: initial_certbot_status

- name: stat letsencrypt status
  stat:
    path: /etc/letsencrypt
  register: initial_letsencrypt_status

# Part of archive routine
# - name: stat letsencrypt archive status
#   stat:
#     path: "{{ letsencrypt_archive }}/{{ i_service_connection.0.ipv4fqdn }}.tar.gz"
#   register: archive_status
#   delegate_to: 127.0.0.1
- name: set timezone
  timezone:
    name: "{{ timezone }}"

- name: update the TLS root certificates
  command: update-ca-trust
  when: initial_letsencrypt_status.stat.exists == False

- name: install python2 virtualenv command
  pip:
    name: ["virtualenv"]
  when: initial_python3_status.stat.exists == False

- name: create python2 virtual environment for letsencrypt
  command: virtualenv /opt/letsencrypt
  when:
  - initial_python3_status.stat.exists == False
  - initial_optdir_status.stat.exists == False

- name: install certbot into the python2 virtual environment
  command: /opt/letsencrypt/bin/pip install certbot
  when:
  - initial_python3_status.stat.exists == False
  - initial_certbot_status.stat.exists == False

- name: create python3 virtual environment for letsencrypt
  command: python3 -m venv /opt/letsencrypt
  when:
  - initial_python3_status.stat.exists == True
  - initial_optdir_status.stat.exists == False

# --- begin python3 certbot
###
# - name: upgrade pip3 to latest version before install certbot
#   command: /opt/letsencrypt/bin/pip3 install --upgrade pip
#   when:
#   - initial_python3_status.stat.exists == True
#   - initial_certbot_status.stat.exists == False

# ###
# - name: install non-broken ssl version for certbot
#   command: /opt/letsencrypt/bin/pip3 install pyOpenSSL==23.1.1
#   when:
#   - initial_python3_status.stat.exists == True
#   - initial_certbot_status.stat.exists == False

# ###
# - name: install certbot into the python3 virtual environment
#   command: /opt/letsencrypt/bin/pip3 install certbot
#   when:
#   - initial_python3_status.stat.exists == True
#   - initial_certbot_status.stat.exists == False

# ---- end of python certbot

- name: ensure the letsencrypt management directory exists
  file:
    dest: /etc/letsencrypt
    state: directory
    owner: root
    group: root
    mode: 0755
  when: 
  - initial_letsencrypt_status.stat.exists == False
  #- archive_status.stat.exists == False

# This is not necessary, no script referencing virtual hosts file any more
# - name: install the virtual hosts configuration file
#   template:
#     src: etc_letsencrypt_VirtualHosts.j2
#     dest: /etc/letsencrypt/VirtualHosts
#     owner: root
#     group: root
#     mode: 0644

# remove
# - name: install custom command to retrieve letsencrypt certificates
#   template:
#     src: usr_local_sbin_get_letsencrypt_cert.j2
#     dest: /usr/local/sbin/get_letsencrypt_cert
#     owner: root
#     group: root
#     mode: 0700

# part of the letsencrypt backup routine
# - name: install the current SSL tar file
#   unarchive:
#     src: "{{ letsencrypt_archive }}/{{ i_service_connection.0.ipv4fqdn }}.tar.gz"
#     dest: /etc/
#   when:
#   - initial_letsencrypt_status.stat.exists == False
#   - archive_status.stat.exists == True
# the behaviour of this tar file is not defined in the new certbot task

- name: Set hostname to FQDN of machine
  ansible.builtin.hostname:
    name: "{{ i_service_connection.0.ipv4fqdn }}"

# - name: run /usr/local/sbin/get_letsencrypt_cert
#   shell: /usr/local/sbin/get_letsencrypt_cert

# - name: install cron task for letsencrypt
#   copy:
#     src: etc_cron.d_get_letsencrypt_cert
#     dest: /etc/cron.d/get_letsencrypt_cert
#     owner: root
#     group: root
#     mode: 0644

# certbot task

# --- certbot install ---
- name: Install snapd for certbot
  ansible.builtin.dnf:
    name: snapd
    state: present

- name: Enable snapd socket
  ansible.builtin.systemd_service:
    name: snapd.socket
    enabled: true

- name: Enable classic snap
  ansible.builtin.file:
    src: /var/lib/snapd/snap
    dest: /snap
    state: link

- name: Ensure snapd socket started
  ansible.builtin.systemd_service:
    name: snapd.socket
    state: started

- name: Install certbot
  community.general.snap:
    classic: true
    name: certbot
    state: present

- name: Prepare certbot command
  ansible.builtin.file:
    src: /snap/bin/certbot
    dest: /usr/bin/certbot
    state: link
# --- end certbot install ---

- name: Register if each virtual_host certificate store exists
  ansible.builtin.stat:
    path: "/etc/letsencrypt/live/{{ item.virtualhost }}"
  loop: "{{ i_virtualhosts }}"
  register: i_virtualhosts_certificates_store

- name: Populate service facts
  ansible.builtin.service_facts:

- name: Stop httpd service if present
  ansible.builtin.systemd_service:
    name: httpd.service
    state: stopped
  when: "'httpd' in services"

- name: Stop HAProxy service if present
  ansible.builtin.systemd_service:
    name: HAProxy.service
    state: stopped
  when: "'HAProxy' in services"

# get firewall status (save if http,https disabled)
- name: Retrieve firewall-cmd stat
  ansible.builtin.stat:
    path: /usr/bin/firewall-cmd
  register: firewall_present

- name: Set firewall_exists to true if firewall-cmd is present
  ansible.builtin.set_fact:
    firewall_present: "{{ firewall_present.stat.exists }}"

- name: Get firewall status
  ansible.posix.firewalld_info:
    zones: public
  register: firewall_status
  when: firewall_present

- name: Register if http service disabled in firewalld
  ansible.builtin.set_fact:
    http_disabled: true
  when:
    - firewall_present
    - "'http' not in firewall_status.firewalld_info.zones.public.services"
    - http_disabled is undefined

- name: Register if https service disabled in firewalld
  ansible.builtin.set_fact:
    https_disabled: true
  when:
    - firewall_present
    - "'https' not in firewall_status.firewalld_info.zones.public.services"
    - https_disabled is undefined

- name: Enable http in firewalld
  ansible.posix.firewalld:
    service: http
    zone: public
    state: enabled
  when: firewall_present

- name: Enable https in firewalld
  ansible.posix.firewalld:
    service: https
    zone: public
    state: enabled
  when: firewall_present

- name: Set up new certificates for virtualhosts
  ansible.builtin.command: certbot -n --standalone -d {{ item.item.virtualhost }} --agree-tos --email {{ admin_email }} certonly
  loop: "{{ i_virtualhosts_certificates_store.results }}"
  when: not item.stat.exists
  changed_when: not item.stat.exists

- name: Certbot renew certificates
  ansible.builtin.command: certbot -n renew
  register: out
  changed_when: out is not search("No renewals were attempted")

- name: Show certbot renewal
  ansible.builtin.debug:
    msg: "{{ out.stdout }}"

- name: Disable http in firewalld if previously disabled
  ansible.posix.firewalld:
    service: http
    zone: public
    state: disabled
  when:
    - firewall_present
    - http_disabled is defined
    - http_disabled

- name: Disable https in firewalld if previously disabled
  ansible.posix.firewalld:
    service: https
    zone: public
    state: disabled
  when:
    - firewall_present
    - https_disabled is defined
    - https_disabled

- name: Start httpd service if present
  ansible.builtin.systemd_service:
    name: httpd.service
    state: started
  when: "'httpd' in services"

- name: Start HAProxy service if present
  ansible.builtin.systemd_service:
    name: HAProxy.service
    state: started
  when: "'HAProxy' in services"

- name: create certificates directory
  file:
    dest: /etc/grid-security/certificates
    state: directory
    owner: root
    group: root
    mode: 0755

- name: install letsencrypt certificte chain
  shell: |
    git clone https://github.com/cilogon/letsencrypt-certificates.git
    cd letsencrypt-certificates/
    make check
    sudo make install
  args:
    executable: /bin/bash

- name: meta
  meta: flush_handlers

# Part of letsencrypt archive
# - name: archive SSL certificates
#   fetch:
#     src: /var/log/letsencrypt/{{ i_service_connection.0.ipv4fqdn }}.tar.gz
#     dest: "{{ letsencrypt_archive }}/{{ i_service_connection.0.ipv4fqdn }}.tar.gz"
#     flat: yes


# to remove:
#common/files/etc_cron.d_copy-certificates-to-users
#common/files/etc_cron.d_get_letsencrypt_cert
#common/templates/etc_letsencrypt_VirtualHosts.j2
#common/templates/usr_local_sbin_get_letsecrypt_cert.j2